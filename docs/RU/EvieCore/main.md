[[Назад]](../../../README%20RU.md)

# EvieCore

## Модули

### UpdateManager

Этот модуль реализует менеджер для обновлений объектов, использующих интерфейс `EvieCoreUpdate`. Он предназначен для того, чтобы централизованно управлять обновлениями компонентов, которые нужно вызывать каждый кадр. 
#### Как использовать:

```csharp
public class ExampleObject : MonoBehaviour, EvieCoreUpdate
{
    private float speed = 5f; // Переменная для скорости движения

    // Этот метод будет вызываться каждый кадр через UpdateManager
    public void OnUpdate()
    {
        // Например, двигаем объект вперед
        transform.Translate(Vector3.forward * speed * Time.deltaTime);
        // Можно добавить дополнительную логику для других обновлений
    }

    void Start()
    {
        // Регистрируем объект в UpdateManager для получения обновлений
        UpdateManager.Instance.Register(this);
    }

    void OnDestroy()
    {
        // Убираем объект из списка обновляемых в UpdateManager
        UpdateManager.Instance.Unregister(this);
    }
}
```

Используйте интерфейс `EvieCoreUpdate` для создания объектов, которые должны получать обновления каждый кадр. Это может быть полезно для таких компонентов, как управление движением, обработка ввода, анимация, обработка логики ИИ, или любые другие задачи, требующие регулярного обновления состояния.
#### Преимущества использования:

- **Централизованное управление обновлениями**: Все объекты, которым нужно обновление каждый кадр, могут быть централизованно управляемы через `UpdateManager`.
- **Легкость добавления новых компонентов**: Когда необходимо добавить новый компонент с логикой обновления, достаточно реализовать интерфейс `EvieCoreUpdate` и зарегистрировать его.
- **Упрощение кода**: Избавляет от необходимости вручную добавлять вызовы обновлений в методах `Update()` множества объектов, уменьшив избыточность и повышая читаемость кода.
### ### DataManager

Этот модуль реализует централизованный менеджер данных, который позволяет хранить и управлять данными различных типов в словаре. `DataManager` предоставляет методы для добавления, получения, удаления и очистки данных по ключам.

#### Как использовать:

```csharp
public class Player : MonoBehaviour
{
    private void Start()
    {
        // Сохраняем данные
        DataManager.Instance.SetData("PlayerScore", 100);
        
        // Получаем данные
        int score = DataManager.Instance.GetData<int>("PlayerScore");
        Debug.Log($"Player's score: {score}");

        // Проверяем наличие данных
        if (DataManager.Instance.ContainsKey("PlayerScore"))
        {
            Debug.Log("Player score exists.");
        }
        
        // Удаляем данные
        DataManager.Instance.RemoveData("PlayerScore");
    }
}

```

#### Методы DataManager:

- **`SetData<T>(string key, T value)`**: Добавляет или обновляет данные в `dataStore` по ключу. Если ключ уже существует, значение обновляется.
- **`GetData<T>(string key)`**: Получает данные по ключу и приводит их к типу `T`. Если данные не найдены или тип данных не совпадает, возвращается значение по умолчанию для типа `T`.
- **`ContainsKey(string key)`**: Проверяет, существует ли запись с указанным ключом.
- **`RemoveData(string key)`**: Удаляет запись с указанным ключом.
- **`ClearAllData()`**: Очищает все данные в `dataStore`.

#### Преимущества использования:

- **Централизованное управление данными**: Все данные могут быть централизованно хранимы и получены через один объект, что упрощает их управление.
- **Гибкость типов**: Благодаря дженерикам можно хранить и извлекать данные любого типа, обеспечивая безопасность типов во время компиляции.
- **Управление жизненным циклом данных**: Легко удалять или очищать данные в любое время, поддерживая актуальность хранимой информации.
- **Простота в использовании**: С помощью ключей можно легко извлекать и изменять данные, что делает работу с ними интуитивно понятной.
### MessageManager

Этот модуль реализует систему сообщений для взаимодействия между объектами. Логика работы напоминает механику событий в Scratch, что делает её интуитивно понятной для тех, кто знаком с этой платформой. **Важно:** использование системы сообщений не всегда считается хорошей практикой, так как может усложнять отслеживание связей между объектами.
#### Как использовать:

```csharp
public class Player : MonoBehaviour
{
    private void Start()
    {
        // Подписка на сообщение без аргументов
        MessageManager.Instance.Subscribe("GameStart", OnGameStart);

        // Подписка на сообщение с аргументом
        MessageManager.Instance.Subscribe<int>("PlayerScored", OnPlayerScored);

        // Отправка сообщения без аргументов
        MessageManager.Instance.SendMessage("GameStart");

        // Отправка сообщения с аргументом
        MessageManager.Instance.SendMessage("PlayerScored", 10);
    }

    private void OnGameStart()
    {
        Debug.Log("Game has started!");
    }

    private void OnPlayerScored(int points)
    {
        Debug.Log($"Player scored {points} points!");
    }

    private void OnDestroy()
    {
        // Отписка от сообщений
        MessageManager.Instance.Unsubscribe("GameStart", OnGameStart);
        MessageManager.Instance.Unsubscribe<int>("PlayerScored", OnPlayerScored);
    }
}
```

#### Методы MessageManager:

- **`Subscribe(string message, Action listener)`**: Подписывает метод на сообщение без аргументов.
- **`Subscribe<T>(string message, Action<T> listener)`**: Подписывает метод на сообщение с аргументом типа `T`.
- **`Unsubscribe(string message, Action listener)`**: Отписывает метод от сообщения без аргументов.
- **`Unsubscribe<T>(string message, Action<T> listener)`**: Отписывает метод от сообщения с аргументом типа `T`.
- **`SendMessage(string message)`**: Отправляет сообщение без аргументов всем подписчикам.
- **`SendMessage<T>(string message, T arg)`**: Отправляет сообщение с аргументом всем подписчикам.
#### Преимущества использования:

- **Гибкость подписки**: Поддерживает сообщения как без аргументов, так и с аргументами произвольного типа.
- **Централизованное управление событиями**: Упрощает взаимодействие между объектами, не требуя их прямой связи.
- **Интуитивность**: Логика работы легко усваивается благодаря схожести с системой Scratch.
- **Динамическое управление подписчиками**: Подписки можно добавлять и удалять в любой момент.
#### Ограничения и рекомендации:

- **Избегайте чрезмерного использования**: Большое количество сообщений может затруднить отладку.
- **Проверяйте типы данных**: Ошибки типа подписчиков могут привести к предупреждениям и непредвиденным ситуациям.
- **Контролируйте отписки**: Всегда отписывайтесь от сообщений в методах вроде `OnDestroy`, чтобы избежать вызовов на удалённые объекты.

### TriggerManager

Этот модуль реализует систему триггеров для игр, позволяющую управлять определёнными состояниями, связанными с событиями или действиями. Например, триггеры могут использоваться для отслеживания выполнения задач, активации объектов или взаимодействия с игровым окружением.

#### Как использовать:

```csharp
public class GameController : MonoBehaviour
{
    private void Start()
    {
        // Добавляем триггеры
        TriggerManager.Instance.AddTrigger("LevelComplete");
        TriggerManager.Instance.AddTrigger("HasKey", false);

        // Устанавливаем состояние триггера
        TriggerManager.Instance.SetTriggerState("HasKey", true);

        // Проверяем состояние триггера
        if (TriggerManager.Instance.GetTriggerState("HasKey"))
        {
            Debug.Log("Player has the key.");
        }

        // Получаем список всех триггеров
        var triggers = TriggerManager.Instance.GetAllTriggers();
        Debug.Log("All triggers: " + string.Join(", ", triggers));
    }
}
```

#### Методы TriggerManager:

- **`AddTrigger(string triggerName, bool initialState = false)`**: Добавляет новый триггер в систему с указанным именем и начальным состоянием. Если триггер уже существует, выводится предупреждение.
- **`SetTriggerState(string triggerName, bool state)`**: Устанавливает новое состояние триггера. Если триггер не существует, выводится ошибка.
- **`GetTriggerState(string triggerName)`**: Возвращает текущее состояние указанного триггера. Если триггер не существует, выводится ошибка, а возвращаемое значение — `false`.
- **`GetAllTriggers()`**: Возвращает список всех добавленных триггеров.

#### Преимущества использования:

- **Централизованное управление состояниями**: Все триггеры управляются через единый объект, что упрощает контроль их текущего состояния.
- **Гибкость в использовании**: Легко добавлять новые триггеры или изменять их состояние в любое время.
- **Удобство интеграции**: Триггеры можно использовать для различных механик, таких как квесты, логика дверей, активация ловушек и многое другое.
- **Простота проверки состояний**: Состояние любого триггера можно быстро проверить в любой части кода.

#### Ограничения и рекомендации:

- **Контроль количества триггеров**: Не добавляйте слишком много триггеров, чтобы избежать сложности в управлении.
- **Структурируйте имена триггеров**: Используйте понятные и уникальные имена для триггеров, чтобы избежать путаницы.
- **Управляйте ошибками**: Убедитесь, что обработка ошибок реализована корректно, особенно если триггеры могут использоваться другими разработчиками.

#### Дополнительные инструменты для TriggerManager:

* Trigger Manager Window - Окно в котором можно изменять триггеры во время игры, это инструмент для отладки игры (открыть можно по следующему пути: Window/EvieCore/Trigger Manager)
* TriggerZone (Prefab и скрипт) - Позволяет создать зоны которые будут срабатывать при попадании объекта (например игрока) и проверять триггеры

## Контроллеры
### FirstPersonController

### SimpleHUD

### TriggerZone